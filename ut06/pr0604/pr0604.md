```
---------------- ADMINISTRACIÓN DE SISTEMAS INFORMÁTICOS Y REDES ----------------
---------------------------------------------------------------------------------

Módulo:                     ADMINISTRACIÓN DE SISTEMAS OPERATIVOS
Profesor:                   Víctor J. González
Unidad de Trabajo:          UT06
Práctica:                   PR0604. Manipulación de colecciones
Resultados de aprendizaje:  RA7
```



# PR0604: Manipulación de colecciones en powerShell

## Bloque I: Arrays fijos

**1. Reconfiguración de DNS y Verificación**

Como administrador, tienes un script que carga los servidores DNS de una sucursal en un array fijo. Se ha detectado que el servidor secundario está caído y la configuración actual es errónea.

- **Pasos a realizar:**

    1.  Declara el array con los valores iniciales: `192.168.1.10` (Primario) y `10.0.0.50` (Secundario erróneo).
    ```bash
    PS C:\Users\Administrador> $ServidoresDNS = @("192.168.1.10", "10.0.0.50")
    ```
    2.  Muestra en pantalla: "Configuración actual: [Primario] - [Secundario]".
    ```bash
    PS C:\Users\Administrador> Write-Host "Configuración actual: $($ServidoresDNS[0]) - $($ServidoresDNS[1])"
    Configuración actual: 192.168.1.10 - 10.0.0.50
    ```
    3.  Accede directamente al índice correspondiente y cambia la IP del secundario por la de Google: `8.8.8.8`.
    ```bash
    PS C:\Users\Administrador> $ServidoresDNS[1] = "8.8.8.8"
    ```
    4.  Muestra en pantalla el número total de servidores DNS configurados.
    ```bash
    PS C:\Users\Administrador> Write-Host "Número total de servidores DNS configurados: $($ServidoresDNS.Count)"
    Número total de servidores DNS configurados: 2
    ```
    5.  Muestra la configuración final corregida.
    ```bash
    PS C:\Users\Administrador> Write-Host "Configuración Final Corregida: $($ServidoresDNS[0]) - $($ServidoresDNS[1])"
    Configuración Final Corregida: 192.168.1.10 - 8.8.8.8
    ```
**2. Rotación de logs de backups (LIFO - Last In, First Out)**

Un sistema antiguo guarda los nombres de los últimos 3 backups en un array. Debes identificar cuál es el más antiguo y cuál el más nuevo para un informe, asumiendo que el índice 0 es el más antiguo.

- **Pasos a realizar:**
- 
    1.  Declara el array con las siguientes cadenas: `Backup_Lunes.zip`, `Backup_Martes.zip`, `Backup_Miercoles.zip`.
    ```bash
    PS C:\Users\Administrador> $Backups = @("Backup_Lunes.zip", "Backup_Martes.zip", "Backup_Miercoles.zip")
    ```
    2.  Guarda en una variable `$oldest` el primer elemento.
    ```bash
    PS C:\Users\Administrador> $oldest = $Backups[0]
    ```
    3.  Guarda en una variable `$newest` el último elemento.
    ```bash
    PS C:\Users\Administrador> $newest = $Backups[-1]
    ```
    4.  El backup del Miércoles ha salido corrupto. Modifica el último elemento del array añadiéndole el texto " (CORRUPTO)" al final del nombre.
    ```bash
    PS C:\Users\Administrador> $Backups[-1] += " (CORRUPTO)"
    ```
    5.  Imprime un resumen: "Rotación de backups: Del [Viejo] al [Nuevo]".
    ```bash
    PS C:\Users\Administrador> Write-Host "Rotación de backups: Del $($oldest) al $($Backups[-1])"
    Rotación de backups: Del Backup_Lunes.zip al Backup_Miercoles.zip (CORRUPTO)
    ```


## Bloque II: ArrayLists


**3. Gestión de Cola de incidencias (Priorización)**

Estás programando un dashboard de soporte técnico. Las incidencias llegan y se ponen en cola. De repente, llega una incidencia crítica del CEO que debe saltarse la cola.

- **Pasos a realizar:**
- 
    1.  Crea un `ArrayList` vacío.
    ```bash
    PS C:\Users\Administrador> $ColaIncidencias = New-Object System.Collections.ArrayList
    ```
    2.  Añade las incidencias: "Monitor parpadea" y "Ratón no va". (Recuerda ocultar la salida por pantalla del `.Add()`).
    ```bash
    PS C:\Users\Administrador> $ColaIncidencias.Add("Monitor parpadea") | Out-Null
    PS C:\Users\Administrador> $ColaIncidencias.Add("Ratón no va") | Out-Null
    ```
    3.  Llega una urgencia: Inserta en la posición 0 la incidencia: "SERVIDOR CAÍDO".
    ```bash
    PS C:\Users\Administrador> $ColaIncidencias.Insert(0, "SERVIDOR CAÍDO")
    ```
    4.  El técnico resuelve la incidencia del "Ratón". Búscala por su nombre y elimínala de la lista.
    ```bash
    PS C:\Users\Administrador> $ColaIncidencias.Remove("Ratón no va") | Out-Null
    ```
    5.  Imprime la lista actual de tareas pendientes y cuenta cuántas quedan.
    ```bash
    PS C:\Users\Administrador> Write-Host "Tareas pendientes restantes: $($ColaIncidencias.Count)"
    Tareas pendientes restantes: 2
    PS C:\Users\Administrador> $ColaIncidencias
    SERVIDOR CAÍDO
    Monitor parpadea
    ```
**4. Validación de lista negra de IPs (Seguridad)**

Tu script de firewall recibe IPs sospechosas y debe decidir si bloquearlas o no.

- **Pasos a realizar:**

    1.  Inicializa un `ArrayList` con las IPs ya bloqueadas: `10.10.10.5`, `192.168.50.4`, `80.80.80.80`.
    ```bash
    PS C:\Users\Administrador> $ListaNegra = New-Object System.Collections.ArrayList
    PS C:\Users\Administrador> $ListaNegra.Add("10.10.10.5") | Out-Null
    PS C:\Users\Administrador> $ListaNegra.Add("192.168.50.4") | Out-Null
    PS C:\Users\Administrador> $ListaNegra.Add("80.80.80.80") | Out-Null
    ```
    2.  Declara una variable `$nuevaAmenaza = "192.168.50.4"`.
    ```bash
    PS C:\Users\Administrador> $nuevaAmenaza = "192.168.50.4"
    ```
    1.  Usa una estructura `if` para:
        - Si la IP ya está en la lista, muestra: "La IP [IP] ya estaba bloqueada. No se hace nada."
        - Si no está, añádela a la lista y muestra: "IP [IP] añadida a la lista negra."
    ```bash
    PS C:\Users\Administrador> if ($ListaNegra -contains $nuevaAmenaza) {
    >>     Write-Host "La IP $nuevaAmenaza ya estaba bloqueada. No se hace nada."
    >> } else {
    >>     $ListaNegra.Add($nuevaAmenaza) | Out-Null
    >>     Write-Host "IP $nuevaAmenaza añadida a la lista negra."
    >> }
    La IP 192.168.50.4 ya estaba bloqueada. No se hace nada.
    ```
    2.  Muestra la lista final ordenada alfabéticamente
    ```bash
    PS C:\Users\Administrador> $ListaNegra.Sort()
    PS C:\Users\Administrador> $ListaNegra
    10.10.10.5
    192.168.50.4
    80.80.80.80
    ```

## Bloque III: Listas genéricas 


**5. Hardening de puertos de Firewall (List[int])**

Vamos a configurar una regla de firewall que solo permite ciertos puertos numéricos.

- **Pasos a realizar:**

    1.  Instancia una nueva lista genérica que solo acepte Enteros: `[System.Collections.Generic.List[int]]::new()`.
    ```bash
    PS C:\Users\Administrador> $PuertosPermitidos = [System.Collections.Generic.List[int]]::new()
    ```
    2.  Añade los puertos estándar: 80, 443, 53.
    ```bash
    PS C:\Users\Administrador> $PuertosPermitidos.Add(80)
    PS C:\Users\Administrador> $PuertosPermitidos.Add(443)
    PS C:\Users\Administrador> $PuertosPermitidos.Add(53)
    ```
    3.  Por error, alguien abrió el puerto Telnet (23). Añádelo a la lista.
    ```bash
    PS C:\Users\Administrador> $PuertosPermitidos.Add(23)
    ```
    4.  Auditoría de seguridad: Elimina el puerto 23 de la lista.
    ```bash
    PS C:\Users\Administrador> $PuertosPermitidos.Remove(23)
    True
    ```
    5.  Intenta añadir (solo escribe la línea comentada) el texto "HTTP" a la lista y explica en un comentario qué error daría.
    ```bash
    PS C:\Users\Administrador> $PuertosPermitidos.Add("HTTP")
    No se puede convertir el argumento "item", con el valor: "HTTP", para "Add", al tipo "System.Int32": "No se puede
    convertir el valor "HTTP" al tipo "System.Int32". Error: "La cadena de entrada no tiene el formato correcto.""
    En línea: 1 Carácter: 1
    + $PuertosPermitidos.Add("HTTP")
    + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        + CategoryInfo          : NotSpecified: (:) [], MethodException
        + FullyQualifiedErrorId : MethodArgumentConversionInvalidCastArgument
    ```
    6.  Muestra la lista de puertos permitidos ordenada de menor a mayor.
    ```bash
    PS C:\Users\Administrador> $PuertosPermitidos.Sort()
    PS C:\Users\Administrador> $PuertosPermitidos
    53
    80
    443
    ```
**6. Inventario de servicios críticos (List[string])**

Necesitas monitorizar una lista de servicios de Windows.

- **Pasos a realizar:**
    1.  Crea una lista genérica de Strings a partir de un array existente (`::new($array)`):
        Array origen: `Spooler`, `W3SVC`, `LanmanWorkstation`.
    ```bash
    PS C:\Users\Administrador> $ServiciosOrigen = @("Spooler", "W3SVC", "LanmanWorkstation")
    PS C:\Users\Administrador> $ServiciosCriticos = [System.Collections.Generic.List[string]]::new([string[]]$ServiciosOrigen)
    ```
    2.  Te das cuenta de que falta el servicio de actualizaciones. Añade "wuauserv".
    ```bash
    PS C:\Users\Administrador> $ServiciosCriticos.Add("wuauserv")
    ```
    3.  Ordena la lista alfabéticamente.
    ```bash
    PS C:\Users\Administrador> $ServiciosCriticos.Sort()
    PS C:\Users\Administrador> $ServiciosCriticos
    LanmanWorkstation
    Spooler
    W3SVC
    wuauserv
    ```
    4.  Recorre la lista (foreach) y para cada elemento muestra el mensaje: "Monitorizando servicio: [NombreServicio]... OK".
    ```bash
    PS C:\Users\Administrador> foreach ($Servicio in $ServiciosCriticos) {
    >>     Write-Host "Monitorizando servicio: $Servicio... OK"
    >> }
    Monitorizando servicio: LanmanWorkstation... OK
    Monitorizando servicio: Spooler... OK
    Monitorizando servicio: W3SVC... OK
    Monitorizando servicio: wuauserv... OK
    ```


#### Bloque IV: Manipulación de texto 

**7. Análisis de Log de usuario**

Tienes una línea de log cruda extraída de un servidor Linux. Necesitas sacar el usuario y la IP limpia.

- **Entrada:** `$logLine = "  User: admin ; IP: 192.168.1.55 ; Status: Failed  "` (Nota los espacios extra al principio y final).
- **Pasos a realizar:**
    1.  Limpia los espacios en blanco sobrantes del principio y el final de la cadena original.
    ```bash
    PS C:\Users\Administrador> $logLine = " User: admin ; IP: 192.168.1.55 ; Status: Failed "
    ```
    2.  Divide la cadena usando el punto y coma `;` como separador.
    ```bash
    PS C:\Users\Administrador> $logLineLimpia = $logLine.Trim()
    PS C:\Users\Administrador> $partes = $logLineLimpia.Split(';')
    ```
    3.  El primer elemento será "User: admin". Vuelve a dividirlo para quedarte solo con "admin".
    ```bash
    PS C:\Users\Administrador> $usuario = $partes[0].Split(':')[1].Trim()
    ```
    4.  El segundo elemento es la IP. Límpialo para obtener solo "192.168.1.55".
    ```bash
    PS C:\Users\Administrador> $ip = $partes[1].Split(':')[1].Trim()
    ```
    5.  Muestra un mensaje final claro: "ALERTA: El usuario [Usuario] intentó conectar desde [IP]".
    ```bash
    PS C:\Users\Administrador> Write-Host "ALERTA: El usuario $usuario intentó conectar desde $ip"
    ALERTA: El usuario admin intentó conectar desde 192.168.1.55
    ```

**8. Generador de CSV para recursos humanos**

RRHH te pide un listado de los correos de los nuevos empleados separados por comas para importarlos en su herramienta de Mailing.

- **Pasos a realizar:**
    1.  Tienes tres variables con correos: `$m1="ana@empresa.com"`, `$m2="luis@empresa.com"`, `$m3="bea@empresa.com"`.
    ```bash
    PS C:\Users\Administrador> $m1 = "ana@empresa.com"
    PS C:\Users\Administrador> $m2 = "luis@empresa.com"
    PS C:\Users\Administrador> $m3 = "bea@empresa.com"
    ```
    2.  Crea un array temporal que contenga esas tres variables.
    ```bash
    PS C:\Users\Administrador> $correosArray = $m1, $m2, $m3
    ```
    3.  Utiliza el operador `-join` para crear una única cadena de texto separada por comas `,`.
    ```bash
    PS C:\Users\Administrador> $correosUnidos = $correosArray -join ","
    ```
    4.  Al resultado final, añádele manualmente el encabezado "EmailAddress," al principio.
    ```bash
    PS C:\Users\Administrador> $encabezado = "EmailAddress,"
    PS C:\Users\Administrador> $csvResultado = $encabezado + $correosUnido
    ```
    5.  Muestra el resultado, que debería parecerse al contenido de un archivo .csv.
    ```bash
    PS C:\Users\Administrador> Write-Host $csvResultado
    EmailAddress,ana@empresa.com,luis@empresa.com,bea@empresa.com
    ```